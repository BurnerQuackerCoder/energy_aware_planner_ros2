// #include <cmath>
// #include <algorithm>
// #include "energy_aware_planner/energy_aware_planner.hpp"
// #include "pluginlib/class_list_macros.hpp"

// PLUGINLIB_EXPORT_CLASS(energy_aware_planner::EnergyAwarePlanner, nav2_core::GlobalPlanner)

// namespace energy_aware_planner
// {

// void EnergyAwarePlanner::configure(
//   const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,
//   std::string name, std::shared_ptr<tf2_ros::Buffer> tf,
//   std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros)
// {
//   auto node = parent.lock();
//   name_ = name;
//   costmap_ros_ = costmap_ros;
//   costmap_ = costmap_ros_->getCostmap();
//   global_frame_ = costmap_ros_->getGlobalFrameID();

//   // Load Parameters from YAML (matching your ROS 1 config style)
//   node->get_parameter_or(name + ".beta_crit", beta_crit_, 0.2);
//   node->get_parameter_or(name + ".k_sigmoid", k_sigmoid_, 10.0);

//   // Setup Battery Subscriber [cite: 131, 501]
//   battery_sub_ = node->create_subscription<std_msgs::msg::Float32>(
//     "/battery", 10, std::bind(&EnergyAwarePlanner::batteryCallback, this, std::placeholders::_1));

//   RCLCPP_INFO(node->get_logger(), "EnergyAwarePlanner Configured. Beta_crit: %.2f", beta_crit_);
// }

// void EnergyAwarePlanner::batteryCallback(const std_msgs::msg::Float32::SharedPtr msg)
// {
//   current_battery_ = msg->data / 100.0; // Convert 0-100 to 0.0-1.0 scale
// }

// double EnergyAwarePlanner::calculateAlpha(double beta)
// {
//   // Implementation of Eq. 3.5 from thesis 
//   return 1.0 / (1.0 + std::exp(k_sigmoid_ * (beta - beta_crit_)));
// }

// void EnergyAwarePlanner::loadZones(const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent) {
//   // For the demo, we'll hardcode the "Main Hallway" zone from your thesis
//   // This can later be moved to the YAML file
//   ZoneDefinition hall;
//   hall.name = "carpeted_hallway";
//   hall.min_mx = 10; hall.max_mx = 50; // Example coordinates
//   hall.min_my = 10; hall.max_my = 50;
//   hall.energy_usage_factor = 5.0;     // High friction (mu = 5.0) [cite: 517, 532]
//   zones_.push_back(hall);
// }

// double EnergyAwarePlanner::getTraversalCost(unsigned int from_idx, unsigned int to_idx, double alpha) {
//   unsigned char cost = costmap_->getCost(to_idx);
  
//   // Obstacle avoidance
//   if (cost >= nav2_costmap_2d::INSCRIBED_INFLATED_OBSTACLE) return -1.0;

//   double d = euclideanDist(from_idx, to_idx);
//   double mu = 1.0; // Default friction

//   // Check if cell is in a high-cost zone
//   unsigned int mx, my;
//   costmap_->indexToCells(to_idx, mx, my);
//   for (const auto& zone : zones_) {
//     if (mx >= zone.min_mx && mx <= zone.max_mx && my >= zone.min_my && my <= zone.max_my) {
//       mu = zone.energy_usage_factor;
//       break;
//     }
//   }

//   // Thesis Eq 3.2: J = (1-alpha)*d + alpha*(mu*d) [cite: 524, 530]
//   return (1.0 - alpha) * d + alpha * (mu * d);
// }

// nav_msgs::msg::Path EnergyAwarePlanner::createPlan(
//   const geometry_msgs::msg::PoseStamped & start,
//   const geometry_msgs::msg::PoseStamped & goal)
// {
//   // Fix unused warnings
//   (void)start; (void)goal;

//   nav_msgs::msg::Path global_path;
//   global_path.header.stamp = rclcpp::Clock().now();
//   global_path.header.frame_id = global_frame_;

//   unsigned int start_idx, goal_idx;
//   costmap_->worldToMap(start.pose.position.x, start.pose.position.y, start_idx);
//   costmap_->worldToMap(goal.pose.position.x, goal.pose.position.y, goal_idx);

//   double alpha = calculateAlpha(current_battery_);
  
//   // A* implementation
//   std::priority_queue<Node, std::vector<Node>, std::greater<Node>> open_set;
//   std::unordered_map<unsigned int, double> g_costs;
//   std::unordered_map<unsigned int, unsigned int> came_from;

//   open_set.push({start_idx, 0.0, euclideanDist(start_idx, goal_idx), start_idx});
//   g_costs[start_idx] = 0.0;

//   while (!open_set.empty()) {
//     Node current = open_set.top();
//     open_set.pop();

//     if (current.index == goal_idx) {
//       // Reconstruct Path
//       unsigned int curr = goal_idx;
//       while (curr != start_idx) {
//         geometry_msgs::msg::PoseStamped pose;
//         double wx, wy;
//         costmap_->mapToWorld(curr % costmap_->getSizeInCellsX(), curr / costmap_->getSizeInCellsX(), wx, wy);
//         pose.pose.position.x = wx;
//         pose.pose.position.y = wy;
//         global_path.poses.push_back(pose);
//         curr = came_from[curr];
//       }
//       std::reverse(global_path.poses.begin(), global_path.poses.end());
//       return global_path;
//     }

//     for (unsigned int neighbor : getNeighbors(current.index)) {
//       double step_cost = getTraversalCost(current.index, neighbor, alpha);
//       if (step_cost < 0) continue;

//       double tentative_g = g_costs[current.index] + step_cost;
//       if (g_costs.find(neighbor) == g_costs.end() || tentative_g < g_costs[neighbor]) {
//         came_from[neighbor] = current.index;
//         g_costs[neighbor] = tentative_g;
//         open_set.push({neighbor, tentative_g, euclideanDist(neighbor, goal_idx), current.index});
//       }
//     }
//   }

//   RCLCPP_WARN(rclcpp::get_logger(name_), "No energy-aware path found!");
//   return global_path;
// }



// void EnergyAwarePlanner::cleanup() {}
// void EnergyAwarePlanner::activate() {}
// void EnergyAwarePlanner::deactivate() {}

// std::vector<unsigned int> EnergyAwarePlanner::getNeighbors(unsigned int index)
// {
//   std::vector<unsigned int> neighbors;
//   unsigned int nx = costmap_->getSizeInCellsX();
//   unsigned int ny = costmap_->getSizeInCellsY();
//   unsigned int mx, my;
//   costmap_->indexToCells(index, mx, my);

//   // Check 8-connected neighbors
//   for (int dx = -1; dx <= 1; ++dx) {
//     for (int dy = -1; dy <= 1; ++dy) {
//       if (dx == 0 && dy == 0) continue;

//       unsigned int nx_mx = mx + dx;
//       unsigned int ny_my = my + dy;

//       if (nx_mx < nx && ny_my < ny) {
//         neighbors.push_back(costmap_->getIndex(nx_mx, ny_my));
//       }
//     }
//   }
//   return neighbors;
// }

// double EnergyAwarePlanner::euclideanDist(unsigned int idx1, unsigned int idx2)
// {
//   unsigned int mx1, my1, mx2, my2;
//   costmap_->indexToCells(idx1, mx1, my1);
//   costmap_->indexToCells(idx2, mx2, my2);
//   return std::hypot(static_cast<double>(mx1) - mx2, static_cast<double>(my1) - my2);
// }

// } // namespace energy_aware_planner